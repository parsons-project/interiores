
package interiores.presentation.swing.views.catalogs;

import interiores.business.controllers.FurnitureTypeController;
import interiores.business.controllers.FurnitureTypesCatalogController;
import interiores.business.events.catalogs.FTCatalogCheckoutEvent;
import interiores.business.events.catalogs.FTCatalogSetModifiedEvent;
import interiores.business.events.catalogs.FTModifiedEvent;
import interiores.business.events.catalogs.FTSetModifiedEvent;
import interiores.core.presentation.SwingController;
import interiores.core.presentation.annotation.Listen;
import interiores.presentation.swing.helpers.FileChooser;
import java.awt.Dimension;
import java.io.File;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.xml.bind.JAXBException;

/**
 * This class represents the furniture type catalog editor, where the user can edit
 * the catalog of furniture types. Options range from creating a new catalog, saving,
 * or loading one, to modifying a determined type of furniture.
 * @author larribas
 */
public class FurnitureTypeCatalogFrame extends javax.swing.JFrame {

    // The frame has access to these controllers, and its own fileChooser
    private SwingController swing;
    private FurnitureTypesCatalogController ftcController;
    private FurnitureTypeController ftController;
    private JFileChooser fileChooser;

    // The frame stores a map containing  all the elements in the currently
    // activer catalog. This map is modified everytime the catalog changes
    // or a particular element does. Changes from any other presentation layer
    // are automatically reflected
    private Map<String,FTCElement> catElements;
    
    // The frame also stores the changes made to the current catalog so far,
    // so that one can save them or discard them
    boolean hasBeenModified = false;
    
    /**
     * Creates the very FTC editor frame
     * @param presentation 
     */
    public FurnitureTypeCatalogFrame(SwingController presentation) {
        // We initialize all the fundamental components of the editor
        initComponents();
        
        // We reference all the approriate controllers internally
        this.swing = presentation;
        ftcController = swing.getBusinessController(FurnitureTypesCatalogController.class);
        ftController = swing.getBusinessController(FurnitureTypeController.class);
        fileChooser = new FileChooser();
        
        // We initialize the data structures the frame will use
        catElements = new HashMap();
        
        // We load the list with all catalogs, set the required visual settings,
        // and load all the elements in the catalog
        initCatalogList();
        initVisualSettings();
        refreshCatalog();
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        title1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jPanel1 = new javax.swing.JPanel();
        currentCatalogSelect = new javax.swing.JComboBox();
        currentCatalogLabel = new javax.swing.JLabel();
        newCatalogButton = new javax.swing.JButton();
        loadCatalogButton = new javax.swing.JButton();
        removeCatalogButton = new javax.swing.JButton();
        saveCatalogButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        newButton = new javax.swing.JButton();
        saveChangesButton = new javax.swing.JButton();
        discardChangesButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Furniture Types Catalog Editor");
        setAlwaysOnTop(true);
        setBackground(new java.awt.Color(255, 255, 255));
        setBounds(new java.awt.Rectangle(0, 0, 900, 600));
        setMinimumSize(new java.awt.Dimension(900, 600));
        setResizable(false);
        setSize(new java.awt.Dimension(900, 700));

        title1.setFont(new java.awt.Font("Lucida Grande", 0, 24)); // NOI18N
        title1.setText("Furniture types catalog editor");
        title1.setVerticalAlignment(javax.swing.SwingConstants.TOP);

        jScrollPane1.setBorder(null);
        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        jScrollPane1.setMinimumSize(new java.awt.Dimension(900, 0));
        jScrollPane1.setViewportView(null);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.setAutoscrolls(true);
        jPanel1.setLayout(new javax.swing.BoxLayout(jPanel1, javax.swing.BoxLayout.PAGE_AXIS));
        jScrollPane1.setViewportView(jPanel1);

        currentCatalogSelect.setBackground(new java.awt.Color(255, 255, 255));
        currentCatalogSelect.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        currentCatalogSelect.setMaximumSize(new java.awt.Dimension(130, 32767));
        currentCatalogSelect.setMinimumSize(new java.awt.Dimension(90, 27));
        currentCatalogSelect.setPreferredSize(new java.awt.Dimension(130, 27));
        currentCatalogSelect.setSize(new java.awt.Dimension(130, 0));
        currentCatalogSelect.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                currentCatalogSelectItemStateChanged(evt);
            }
        });

        currentCatalogLabel.setText("Current catalog:");

        newCatalogButton.setText("New Catalog");
        newCatalogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newCatalogButtonActionPerformed(evt);
            }
        });

        loadCatalogButton.setText("Load Catalog");
        loadCatalogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadCatalogButtonActionPerformed(evt);
            }
        });

        removeCatalogButton.setText("Remove Catalog");
        removeCatalogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeCatalogButtonActionPerformed(evt);
            }
        });

        saveCatalogButton.setText("Save Catalog");
        saveCatalogButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveCatalogButtonActionPerformed(evt);
            }
        });

        jLabel1.setText("Add a new type of furniture");

        ImageIcon im = new javax.swing.ImageIcon("src/resources/add_element.png");
        im.setImage( im.getImage().getScaledInstance(35,35,java.awt.Image.SCALE_SMOOTH) );
        newButton.setIcon(im); // NOI18N
        newButton.setBorder(BorderFactory.createEmptyBorder());
        newButton.setContentAreaFilled(false);
        newButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                newButtonActionPerformed(evt);
            }
        });

        saveChangesButton.setText("Save changes");
        saveChangesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveChangesButtonActionPerformed(evt);
            }
        });

        discardChangesButton.setText("Discard changes");
        discardChangesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                discardChangesButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createSequentialGroup()
                                .add(newCatalogButton)
                                .add(18, 18, 18)
                                .add(loadCatalogButton))
                            .add(title1))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                            .add(layout.createSequentialGroup()
                                .add(saveCatalogButton)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(removeCatalogButton))
                            .add(layout.createSequentialGroup()
                                .add(currentCatalogLabel)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                                .add(currentCatalogSelect, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                        .addContainerGap())
                    .add(layout.createSequentialGroup()
                        .add(discardChangesButton)
                        .add(181, 181, 181)
                        .add(newButton)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jLabel1)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(saveChangesButton))))
            .add(layout.createSequentialGroup()
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 900, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(0, 6, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(title1)
                    .add(currentCatalogLabel)
                    .add(currentCatalogSelect, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(18, 18, 18)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(newCatalogButton)
                    .add(loadCatalogButton)
                    .add(removeCatalogButton)
                    .add(saveCatalogButton))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 515, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(discardChangesButton)
                    .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                        .add(newButton)
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                            .add(jLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(saveChangesButton))))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Triggers when a different catalog is selected. It basically performs a checkout to the selected catalog
     */
    private void currentCatalogSelectItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_currentCatalogSelectItemStateChanged
        if (!hasBeenModified) ftcController.checkout(currentCatalogSelect.getSelectedItem().toString());
    }//GEN-LAST:event_currentCatalogSelectItemStateChanged

    /**
     * Triggers when the "Load catalog" button is pressed. It opens a fileChooser dialog and loads the selected catalog
     */
    private void loadCatalogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadCatalogButtonActionPerformed
        loadCatalog();
    }//GEN-LAST:event_loadCatalogButtonActionPerformed

    /**
     * Triggers when the "Save catalog" button is pressed. It opens a fileChooser dialog and saves 
     * the current catalog to the specified path, under the specified name
     */
    private void saveCatalogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveCatalogButtonActionPerformed
        saveCatalog();
    }//GEN-LAST:event_saveCatalogButtonActionPerformed

    /**
     * Triggers when the "Remove catalog" button is pressed. It removes the current catalog
     * and checks out the default one (which cannot be modified or removed)
     */
    private void removeCatalogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeCatalogButtonActionPerformed
        if (!hasBeenModified) {
            ftcController.checkout("default");
            ftcController.remove(currentCatalogSelect.getSelectedItem().toString());
        }
        else showModificationWarning();
    }//GEN-LAST:event_removeCatalogButtonActionPerformed

    /**
     * Triggers when the "New catalog" button is pressed. It shows a dialog asking the
     * properties of the new catalog, and creates it.
     */
    private void newCatalogButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newCatalogButtonActionPerformed
        if (!hasBeenModified) {
            NewCatalogDialog newCat = new NewCatalogDialog(ftcController);
            newCat.setVisible(true);
        }
        else showModificationWarning();
    }//GEN-LAST:event_newCatalogButtonActionPerformed

    /**
     * Triggers when the "New element" (+) button is pressed. It shows a dialog asking the
     * properties of the new element, and creates it.
     */
    private void newButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_newButtonActionPerformed
        performModification();
        NewFurnitureTypeDialog ftd = new NewFurnitureTypeDialog(ftController);
        ftd.setVisible(true);
    }//GEN-LAST:event_newButtonActionPerformed

    /**
     * Triggers when the "Discard changes" button is pressed. It forgets about all the changes,
     * eliminates the temporarily modified catalog (if any), and closes the window
     */
    private void discardChangesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_discardChangesButtonActionPerformed
        if (hasBeenModified) discardChanges((String) currentCatalogSelect.getSelectedItem());
        dispose();
    }//GEN-LAST:event_discardChangesButtonActionPerformed

    /**
     * Triggers when the "Save changes" button is pressed. It merges all the changes,
     * done in the temporarily modified catalog "name(mod)" with the actual catalog,
     * eliminates 'name(mod)', and closes the window
     */
    private void saveChangesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveChangesButtonActionPerformed
        if (hasBeenModified) saveChanges((String) currentCatalogSelect.getSelectedItem());
        dispose();
    }//GEN-LAST:event_saveChangesButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel currentCatalogLabel;
    private javax.swing.JComboBox currentCatalogSelect;
    private javax.swing.JButton discardChangesButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton loadCatalogButton;
    private javax.swing.JButton newButton;
    private javax.swing.JButton newCatalogButton;
    private javax.swing.JButton removeCatalogButton;
    private javax.swing.JButton saveCatalogButton;
    private javax.swing.JButton saveChangesButton;
    private javax.swing.JLabel title1;
    // End of variables declaration//GEN-END:variables

    /**
     * Shows a fileChooser open dialog and lets the user select the file
     * from which a new catalog is to be loaded
     */
    private void loadCatalog() {
        int status = fileChooser.showOpenDialog(this);
        
        if(status == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            
            try {
                ftcController.load(file.getAbsolutePath());
            }
            catch(JAXBException e) {
            }
        }
    }
    
    /**
     * Shows a fileChooser save dialog and lets the user select the file
     * to where the current catalog is to be saved
     */
    private void saveCatalog() {
        int status = fileChooser.showSaveDialog(this);
        
        if(status == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            
            try {
                ftcController.save(file.getAbsolutePath());
            }
            catch(JAXBException e) {
                
            }
        }
    }
    
    /**
     * This function is invoked whenever a particular element of the catalog
     * is added or removed, so that those changes reflect upon this frame
     * @param evt The tell-tale event
     */
    @Listen({FTSetModifiedEvent.class})
    public void updateCatalogElementSet(FTSetModifiedEvent evt) {
        if (evt.isAdded()) addElement(evt.getFullName(),evt.getName());
        else {
            removeElement(evt.getFullName());
            if (catElements.isEmpty()) showEmptyCatalogMessage();
        }
        refresh();
    }
    
     /**
     * This function is invoked whenever a particular element of the catalog
     * is modified, so that those changes reflect upon this frame
     * @param evt The tell-tale event
     */
    @Listen({FTModifiedEvent.class})
    public void updateCatalogElement(FTModifiedEvent evt) {
        catElements.get(evt.getFullName()).updateChanges();
    }

    /**
     * This function is invoked whenever the list of available catalog changes,
     * so that those changes reflect upon this frame
     * @param evt The tell-tale event
     */
    @Listen({FTCatalogSetModifiedEvent.class})
    public void updateCatalogList(FTCatalogSetModifiedEvent evt) {
        if (evt.isAdded()) currentCatalogSelect.addItem(evt.getName());
        else currentCatalogSelect.removeItem(evt.getName());
    }
    
    /**
     * This function is invoked whenever the currently selected catalog changes,
     * so that those changes reflect upon this frame
     * @param evt The tell-tale event
     */
    @Listen({FTCatalogCheckoutEvent.class})
    public void updateSelectedCatalog(FTCatalogCheckoutEvent evt) {
        currentCatalogSelect.setSelectedItem(evt.getName());
        refreshCatalog();
    }
    
    /**
     * This method is called when a full recognition of the current catalog's
     * elements is needed. It clears the element list and loads the appropriate one
     */
    private void refreshCatalog() {
        clearElements();
        
        // Retrieve all the elements in the catalog
        Map<String,String> ftypes = ftController.getFullNamesMap();
        
        if (ftypes.isEmpty()) showEmptyCatalogMessage();
        else {
            // Each 'key' has the full name of the furniture, which in turn is accessed by its short name
            for (String key : ftypes.keySet()) {
                String ftn = ftypes.get(key); // 'ftn' is the short name (its actual name within the program)
                addElement(key, ftn);
            }
        }
        refresh();
    }

    /**
     * Loads a new element to the current catalog display
     * @param fname The full name of the element (e.g. Single Bed)
     * @param sname The short (internal) id of the element (e.g. singleBed)
     */
    private void addElement(String fname, String sname) {
        FTCElement ftcInstance = new FTCElement(swing,sname,fname,this);
        jPanel1.add(ftcInstance);
        catElements.put(fname, ftcInstance);
    }
    
    /**
     * Removes a specific element from the current catalog display
     * @param key The key the element has in the internal data structure of the frame
     */
    private void removeElement(String key) {
        if (catElements.containsKey(key)) {
            jPanel1.remove(catElements.get(key) );
            catElements.remove(key);
        }
    }
    
    /**
     * Clears all the catalog elements currently loaded.
     * This work is needed not only visually but also structurally
     */
    private void clearElements() {
        jPanel1.removeAll();
        catElements.clear();
    }
    
    /**
     * It loads the available catalogs into the frame
     */
    private void initCatalogList() {
        Collection<String> catalogs = ftcController.getNamesLoadedCatalogs();
        Object[] s = catalogs.toArray();
        currentCatalogSelect.setModel(new javax.swing.DefaultComboBoxModel(s) );
        currentCatalogSelect.setSelectedItem("session");
    }
    
    /**
     * Groups all the custom visual setting this frame has to initialize when loading
     */
    private void initVisualSettings() {
        
    }

    /**
     * Groups the appropriate swing routine we have to perform each time we need to
     * refresh (or redraw) the contents of the main panel
     */
    private void refresh() {
        jPanel1.revalidate();
        jPanel1.repaint();
    }
    
    public void performModification() {
        if (!hasBeenModified) {
            hasBeenModified = true;
            String currM = (String) currentCatalogSelect.getSelectedItem() + "(mod)";
            ftcController.create(currM);
            ftcController.checkout(currM);
        }        
    }
    
    /**
     * Given the name of a modified catalog, it saves all the changes and erases the modified version
     * @param modCat The name of the modified catalog (e.g. session(mod) )
     */
    private void saveChanges(String modCat) {
        hasBeenModified = false;
        ftcController.checkout(modCat.substring(0, modCat.length()-5));
        ftcController.replace(modCat);
        ftcController.remove(modCat);
    }
    
    /**
     * Given the name of a modified catalog, it discards all the changes and erases the modified version
     * @param modCat The name of the modified catalog (e.g. session(mod) )
     */
    private void discardChanges(String modCat) {
        hasBeenModified = false;
        ftcController.checkout(modCat.substring(0,modCat.length()-5));
        ftcController.remove(modCat);
    }
    
    private void showModificationWarning() {
        int choice = JOptionPane.showConfirmDialog(this,"The current catalog has been modified. Do you want to save those changes?",
                                                    "Save changes", JOptionPane.YES_NO_OPTION);
        
        String curr = (String) currentCatalogSelect.getSelectedItem();
        if (choice == JOptionPane.NO_OPTION) discardChanges(curr);
        else saveChanges(curr);
    }
    
    private void showEmptyCatalogMessage() {
        javax.swing.JLabel emptyLabel = new javax.swing.JLabel();
        emptyLabel.setFont(new java.awt.Font("Lucida Grande", 0, 16)); // NOI18N
        emptyLabel.setText("There isn't any furniture type defined in catalog "
                + currentCatalogSelect.getSelectedItem().toString() );
        jPanel1.add(emptyLabel);
    }

    /**
     * This class is a visual representation of a catalog item.
     * It serves as an auxiliary data structure to hold a whole information pane
     * with its own features, events, and properties.
     */
    class FTC_Element {
        // The actual name of the element contains its internal name within the application
        private String actualName;
        // ftname, on the other hand, contains a visually clearer name
        private javax.swing.JLabel ftname = new javax.swing.JLabel();
        
        // The outer panel holds the remove button and the inner panel
        private javax.swing.JPanel outerPanel = new javax.swing.JPanel();
            private javax.swing.JButton removeButton = new javax.swing.JButton();
            private javax.swing.JPanel innerPanel = new javax.swing.JPanel();
        
        // The inner panel holds all the labels and text fields related to the properties of an element
        private javax.swing.JLabel widthLabel = new javax.swing.JLabel();
        private javax.swing.JLabel widthLabel2 = new javax.swing.JLabel();
        private javax.swing.JLabel widthLabel3 = new javax.swing.JLabel();
        private javax.swing.JTextField minWidthField = new javax.swing.JTextField();
        private javax.swing.JTextField maxWidthField = new javax.swing.JTextField();
        
        private javax.swing.JLabel depthLabel = new javax.swing.JLabel();
        private javax.swing.JLabel depthLabel2 = new javax.swing.JLabel();
        private javax.swing.JLabel depthLabel3 = new javax.swing.JLabel();
        private javax.swing.JTextField minDepthField = new javax.swing.JTextField();
        private javax.swing.JTextField maxDepthField = new javax.swing.JTextField();

        private javax.swing.JLabel passiveSpaceLabel = new javax.swing.JLabel();
        private javax.swing.JLabel passiveSpaceHint = new javax.swing.JLabel();
        private javax.swing.JTextField passiveSpaceField = new javax.swing.JTextField();
        
        private boolean hasWidthChanged = false;
        private boolean hasDepthChanged = false;
        private boolean hasPassiveSpaceChanged = false;
                
        /**
         * Builds a visual representation of the item in the currently active catalog
         * whose name is 'actname'
         * @param actname The actual (internal) id of the element
         * @param fullname A visually clearer name for such an element
         */
        public FTC_Element(String actname, String fullname) {

            actualName = actname;
            
            // We set the properties of the outer panel
            outerPanel.setBackground(new java.awt.Color(255, 255, 255));
            outerPanel.setPreferredSize(new Dimension(750,250));
            outerPanel.setSize(new Dimension(750, 250));
            outerPanel.setMinimumSize(new Dimension(750, 250));
            outerPanel.setMaximumSize(new Dimension(750, 250));
            
            // These lines substitute the default aspect of a button with a custom icon
            ImageIcon im = new javax.swing.ImageIcon("src/resources/remove_element.png");
            im.setImage( im.getImage().getScaledInstance(40,40,java.awt.Image.SCALE_SMOOTH) );
            removeButton.setIcon(im);
            removeButton.setBorder(BorderFactory.createEmptyBorder());
            removeButton.setContentAreaFilled(false);
            removeButton.addActionListener(new java.awt.event.ActionListener() {
            @Override
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                    performModification();
                    ftController.rm(actualName);
                }
            });
            
            // Properties of the inner panel
            innerPanel.setBackground(new java.awt.Color(255, 255, 255));
            innerPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(204, 204, 204)));
            
            // Name of the element
            ftname.setFont(new java.awt.Font("Lucida Grande", 0, 16)); // NOI18N
            ftname.setText(fullname + ":");
            
            // Width setup and events
            widthLabel.setText("This furniture should have a width between");
            widthLabel2.setText("and");
            widthLabel3.setText("cm");
            minWidthField.setText(Integer.toString(ftController.getWidthRange(actualName).min));
            maxWidthField.setText(Integer.toString(ftController.getWidthRange(actualName).max));
            minWidthField.getDocument().addDocumentListener(new DocumentListener() {
                @Override
                public void changedUpdate(DocumentEvent e) { hasWidthChanged = true; }
                @Override
                public void insertUpdate(DocumentEvent e) {  hasWidthChanged = true;  }
                @Override
                public void removeUpdate(DocumentEvent e) {  hasWidthChanged = true;  }
             });
            maxWidthField.getDocument().addDocumentListener(new DocumentListener() {
                @Override
                public void changedUpdate(DocumentEvent e) {  hasWidthChanged = true; }
                @Override
                public void insertUpdate(DocumentEvent e) {  hasWidthChanged = true;  }
                @Override
                public void removeUpdate(DocumentEvent e) {  hasWidthChanged = true;  }
             });
            minWidthField.addFocusListener(new java.awt.event.FocusAdapter() {
                @Override
                public void focusLost(java.awt.event.FocusEvent evt) { if (hasWidthChanged) widthRangeUpdate(); }
            });
            maxWidthField.addFocusListener(new java.awt.event.FocusAdapter() {
                @Override
                public void focusLost(java.awt.event.FocusEvent evt) { if (hasWidthChanged) widthRangeUpdate(); }
            });
            
            // Depth setup and events
            depthLabel.setText("And a depth between");
            depthLabel2.setText("and");
            depthLabel3.setText("cm");
            minDepthField.setText(Integer.toString(ftController.getDepthRange(actualName).min));
            maxDepthField.setText(Integer.toString(ftController.getDepthRange(actualName).max));
            minDepthField.getDocument().addDocumentListener(new DocumentListener() {
                @Override
                public void changedUpdate(DocumentEvent e) { hasDepthChanged = true; }
                @Override
                public void insertUpdate(DocumentEvent e) { hasDepthChanged = true; }
                @Override
                public void removeUpdate(DocumentEvent e) { hasDepthChanged = true; }
             });
            maxDepthField.getDocument().addDocumentListener(new DocumentListener() {
                @Override
                public void changedUpdate(DocumentEvent e) { hasDepthChanged = true; }
                @Override
                public void insertUpdate(DocumentEvent e) { hasDepthChanged = true; }
                @Override
                public void removeUpdate(DocumentEvent e) { hasDepthChanged = true; }
             });
            minDepthField.addFocusListener(new java.awt.event.FocusAdapter() {
                @Override
                public void focusLost(java.awt.event.FocusEvent evt) { if (hasDepthChanged) depthRangeUpdate(); }
            });
            maxDepthField.addFocusListener(new java.awt.event.FocusAdapter() {
                @Override
                public void focusLost(java.awt.event.FocusEvent evt) { if (hasDepthChanged) depthRangeUpdate(); }
            });
            
            // Passive space fields
            passiveSpaceLabel.setText("It should always have the following free space to its sides:");
            passiveSpaceHint.setFont(new java.awt.Font("Lucida Grande", 2, 13)); // NOI18N
            passiveSpaceHint.setForeground(new java.awt.Color(153, 153, 153));
            passiveSpaceHint.setText("Format: N,E,S,W. e.g. 10,0,0,20");
            passiveSpaceField.setText(getFormattedPassiveSpace());
            passiveSpaceField.getDocument().addDocumentListener(new DocumentListener() {
                @Override
                public void changedUpdate(DocumentEvent e) { hasPassiveSpaceChanged = true; }
                @Override
                public void insertUpdate(DocumentEvent e) { hasPassiveSpaceChanged = true; }
                @Override
                public void removeUpdate(DocumentEvent e) { hasPassiveSpaceChanged = true; }
             });
            passiveSpaceField.addFocusListener(new java.awt.event.FocusAdapter() {
                @Override
                public void focusLost(java.awt.event.FocusEvent evt) { if (hasPassiveSpaceChanged) passiveSpaceUpdate(); }
            });

            // Finally, we lay out all the visual components, assemble them and finish
            org.jdesktop.layout.GroupLayout innerPanelLayout = new org.jdesktop.layout.GroupLayout(innerPanel);
            innerPanel.setLayout(innerPanelLayout);
            innerPanelLayout.setHorizontalGroup(
                innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(innerPanelLayout.createSequentialGroup()
                    .addContainerGap()
                    .add(ftname)
                    .add(62, 62, 62)
                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                        .add(innerPanelLayout.createSequentialGroup()
                            .add(11, 11, 11)
                            .add(passiveSpaceHint, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 207, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(33, 33, 33)
                            .add(passiveSpaceField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 128, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .add(org.jdesktop.layout.GroupLayout.TRAILING, innerPanelLayout.createSequentialGroup()
                            .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                                .add(innerPanelLayout.createSequentialGroup()
                                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                                        .add(depthLabel)
                                        .add(widthLabel))
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                        .add(minWidthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 50, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                        .add(minDepthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 50, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                        .add(innerPanelLayout.createSequentialGroup()
                                            .add(widthLabel2)
                                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                            .add(maxWidthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 50, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                            .add(widthLabel3))
                                        .add(innerPanelLayout.createSequentialGroup()
                                            .add(depthLabel2)
                                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                            .add(maxDepthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 50, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                            .add(depthLabel3))))
                                .add(innerPanelLayout.createSequentialGroup()
                                    .add(passiveSpaceLabel)
                                    .add(81, 81, 81)))
                            .add(15, 15, 15)))
                    .add(6, 6, 6))
            );
            innerPanelLayout.setVerticalGroup(
                innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(innerPanelLayout.createSequentialGroup()
                    .addContainerGap()
                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                        .add(ftname)
                        .add(widthLabel)
                        .add(minWidthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(widthLabel2)
                        .add(maxWidthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(widthLabel3))
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                        .add(depthLabel)
                        .add(minDepthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(depthLabel2)
                        .add(maxDepthField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(depthLabel3))
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                    .add(passiveSpaceLabel)
                    .add(18, 18, 18)
                    .add(innerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                        .add(passiveSpaceField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(passiveSpaceHint))
                    .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            );

            org.jdesktop.layout.GroupLayout outerPanelLayout = new org.jdesktop.layout.GroupLayout(outerPanel);
            outerPanel.setLayout(outerPanelLayout);
            outerPanelLayout.setHorizontalGroup(
                outerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(org.jdesktop.layout.GroupLayout.TRAILING, outerPanelLayout.createSequentialGroup()
                    .addContainerGap(18, Short.MAX_VALUE)
                    .add(removeButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 51, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                    .add(innerPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    )
            );
            outerPanelLayout.setVerticalGroup(
                outerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(org.jdesktop.layout.GroupLayout.TRAILING, outerPanelLayout.createSequentialGroup()
                    .addContainerGap(27, Short.MAX_VALUE)
                    .add(outerPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                        .add(removeButton)
                        .add(innerPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .addContainerGap())
            );
        }

        /**
         * Everything built, this operation adds the outer panel to the frame display 
         */
        public void addToPanel() {
            jPanel1.add(outerPanel);
        }
        
        /**
         * Everything built, this operation removes the outer panel from the frame display
         */
        public void removeFromPanel() {
            jPanel1.remove(outerPanel);
        }
        
        /**
         * Consults all over again the information of the item and updates its state
         */
        public void updateChanges() {
            minWidthField.setText(Integer.toString(ftController.getWidthRange(actualName).min));
            maxWidthField.setText(Integer.toString(ftController.getWidthRange(actualName).max));
            minDepthField.setText(Integer.toString(ftController.getDepthRange(actualName).min));
            maxDepthField.setText(Integer.toString(ftController.getDepthRange(actualName).max));
            passiveSpaceField.setText(getFormattedPassiveSpace());
        }     
        
        private void widthRangeUpdate() {
            hasWidthChanged = false;
            String min = minWidthField.getText();
            String max = maxWidthField.getText();
            if (min.matches("[0-9]+") && max.matches("[0-9]+")) {
                performModification();
                ftController.setWidthRange(actualName, Integer.parseInt(min), Integer.parseInt(max));
            }
            else {
                String msg = "Width should be a positive number";
                JOptionPane.showMessageDialog(FurnitureTypeCatalogFrame.this,msg,"Invalid value",JOptionPane.ERROR_MESSAGE);
                minWidthField.setText(Integer.toString(ftController.getWidthRange(actualName).min));
                maxWidthField.setText(Integer.toString(ftController.getWidthRange(actualName).max));
            }
        }
        
        private void depthRangeUpdate() {
            hasDepthChanged = false;
            String min = minDepthField.getText();
            String max = maxDepthField.getText();
            if (min.matches("[0-9]+") && max.matches("[0-9]+")) {
                performModification();
                ftController.setDepthRange(actualName, Integer.parseInt(min), Integer.parseInt(max));
            }
            else {
                String msg = "Depth should be a positive number";
                JOptionPane.showMessageDialog(FurnitureTypeCatalogFrame.this,msg,"Invalid value",JOptionPane.ERROR_MESSAGE);
                minDepthField.setText(Integer.toString(ftController.getDepthRange(actualName).min));
                maxDepthField.setText(Integer.toString(ftController.getDepthRange(actualName).max));
            }
        }
        
        private void passiveSpaceUpdate() {
            hasPassiveSpaceChanged = false;
            String str = passiveSpaceField.getText();
            str = str.replace(" ","");
            String[] s_ps = str.split(",");
            String passive = getFormattedPassiveSpace();
            try {
                performModification();
                int[] i_ps = new int[4];
                for(int i = 0; i < Math.min(4, s_ps.length); i++) i_ps[i] = Integer.parseInt(s_ps[i]);
                ftController.setPassiveSpace(actualName, i_ps);
            }
            catch (Exception e) {
                JOptionPane.showMessageDialog(FurnitureTypeCatalogFrame.this,e.getMessage(),"Invalid value",JOptionPane.ERROR_MESSAGE);
                passiveSpaceField.setText(passive);
            }
        }
        
        private String getFormattedPassiveSpace() {
            int[] ps = ftController.getPassiveSpace(actualName);
            return ps[0] + ", " + ps[1] + ", " + ps[2] + ", " + ps[3];
        }
        
    }
    /*
     * End of RTC_Element Class
     */

}
/*
 * End of the main class
 */
