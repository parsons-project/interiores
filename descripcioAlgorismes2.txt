Breu descripció de les estructures de dades i algorismes utilitzats per a implementar les funcionalitats principals.

Introducció

En un problema de satisfacció de restriccions (CSP), tenim un conjunt de variables, cadascuna amb un domini de valors, i un conjunt de restriccions que relacionen els valors d'aquestes variables.
En el cas de disseny d'interiors, les variables son tipus de moble, mentre que els valors consten de 3 camps: posició, model de moble i orientació.
L'algorisme utilitzat es basa en forward checking: cada cop que s'assigna un valor a una variable, es comprova el domini de les variables que encara no han estat assignades i s'elimina dels seus dominis aquells valors incompatibles amb el valor assignat. Tot i això, aquesta operació no és exhaustiva, i per tant és necessari garantir que el valor realment és vàlid. Finalment, en cas d’haver de fer un pas enrera, caldrà desfer els canvis en els dominis de les variables.

Aquest esquema ens defineix tres operacions crítiques per al rendiment de l’algorisme.
trimDomains()
canPlace()
undoTrimDomains()

Les estructures de dades de cada variable

Per guardar el domini de les variables hem decidit guardar cada camp (model, posició i orientació) per separat. Tenim un conjunt per cada un d’aquests atributs i el domini és el seu producte cartesià. Les implicacions d’aquesta decisió són que utilitzem una fracció molt reduïda de memòria, i que podem eliminar múltiples valors del domini en una sola operació (per exemple, tots els valors que tenen un model). Per contra, perdem granularitat (per exemple, no podem eliminar una posició per un moble concret).

Els models els hem ficat en una llista. A cada iteració de l’algorisme fins que se li assigna un valor, trimDomain() agafa els models que continuen sent vàlids i els mou a una nova llista. Per tant, tenim un vector de llistes en que a cada posició podem veure els models que han deixat de ser vàlids. Aquesta decisió implica que l’ús de memòria és constant, que recòrrer el conjunt de mobles vàlids serà menys costós a cada iteració i que l’operació undoTrimDomain() la podem fer en temps constant concatenant la llista corresponent a la iteració actual amb l’anterior.

Per les posicions, una llista no ens serveix ja que el conjunt estimem que serà molt més gran i el temps d’accés no seria acceptable. Per això, les posicions es troben en un HashSet, que és una taula de hash d’elements únics. Anàlogament als models, a cada iteració movem els valors que romanen vàlids a un nou HashSet. En aquest cas, per això, la operació undoTrimDomain() consistirà en unir dos sets element a element.


Una optimització a considerar per la tercera entrega consisteix en substituir els HashSets per una estructura pròpia, que consisteix en representar les posicions vàlides amb booleans en una matriu de la mida de l’habitació. Per tal de no haver de recórrer tota la matriu al recórrer el domini, les posicions vàlides estarien linkejades com en una linked list (sense cap ordre especial). Així es pot accedir a una posició més ràpidament que en un hashset i s’eviten les operacions de redimensió dels hashsets. Per contra, l’ús de memòria s’incrementa en un factor equivalent a el nombre de iteracions, ja que es necessita una matriu per cada una).

Una altra optimització ja aplicada tant al vector de llistes com al de HashSets consisteix en que, si preveiem que caldrà moure la majoria d’elements, primer fer un swap() del conjunt origen i destí (cost constant en java, ja que només modifiquem les referències) i moure des del destí a l’origen els elements que no s’havien de moure. Aquesta optimització funciona molt bé ja que, en general, estimem que els valors del domini que es descarten a cada iteració són pocs.

El conjunt d’orientacions és estàtic i està en una llista de 4 elements, que no muta d’iteració en iteració.

Finalment, les variables guarden en una llista les seves restriccions unàries, aquelles que només les incumbeixen a elles. Aquestes restriccions s’utilitzen per descartar valors del domini en un pas previ al backtracking, i per tant el cost d’evaluar-les no és rellevant per en quant a l’eficiència de l’algorisme.

Les estructures de dades del conjunt de variables

Les variables es guarden en un vector, ordenades per ordre en que han estat assignades. Les variables encara sense valor assignat es troben a les darreres posicions, sense cap ordre particular. Això ens permet, sabent la iteració actual, recórrer només les variables que encara no han estat assignades, quelcom desitjable per operacions com next() (operació que tria la següent variable a assignar d’entre les que no tenen valor).

El conjunt de variables també emmagatzema les restriccions binàries, aquelles que relacionen més d’una variable. Les restriccions binàries es guarden en un HashMap, ...

Els detalls de l'algorisme

Hem volgut evitar comtre l'error d'optimització prematura. Per això, la versió actual és provisional i no està optimitzada. Moltes de les funcionalitats descrites en aquest apartat seran afegides per la versió final; no obstant, hem triat les estructures de dades per tal que sigui factible afegir-les.
A continuació, 

1. PreliminarTrimDomains()
Aquí s'eliminarà, per cada variable: 
Els models que no satisfaguin alguna restricció unària.
Els models tals que la suma del seu preu més el preu del moble més barat de la resta de variables supera el pressupost exigit.
Dels restants, els models tals que existex un altre model més curt, més estret i més barat.
Les posicions tals que ni el moble més curt ni el moble més llarg hi caben, tenint en compte parets i elements fixes.
A més, s'ordenaran els models de més petit a més gran (i en cas d'empat, per preu), per tal que  al iterar pel domini s'escullin mobles el més apropiats possible.

2.  next()
Per triar la variable següent, es farà un valoració ponderada de tres factors:
La grandària del moble més petit
La grandària del domini
El nombre i característiques de restriccions binàries

3. trimDomains()
Es descarta, per cada variable:
Les posicions ocupades pel nou moble (això és l'únic que està implementat a la versió actual) així com aquelles tals que el moble més estret i el més curt xocarien amb el nou moble.
L'anàleg però amb les posicions ocupades per l'espai passiu del nou moble (l'espai necessari per utilitzar-lo).