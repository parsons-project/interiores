package interiores.shared.backtracking;/*** VariableSet represents a set of variables, each of them with a domain of* values it can take. A variable might be assigned to a value, or unassigned.* The variables also have restrictions.* * The union of variables and restrictions define the context of a Constraint* Satisfaction Problem (CSP).* A solution to the CSP has been found when each variable has an assigned value* from its domain such that no restriction is violated.* * Notation* If the CSP algorithm is in action, the variable which is trying to be assigned* in the current iteration is denominated the "actual" variable.* When we try to assign a value to the actual variable, we say we are checking* that value.*/public abstract class VariableSet{    /**     * Represents the level of recursion of the CSP algorithm.     */    protected int depth;            /**     * Default constructor.     */    public VariableSet() {    }    /**    * Given there is at least one variable without an assigned value, chooses    * the one that the algorithm should try to allocate next. That is,    * determines the actual variable.    */    protected abstract void setActualVariable();        /**    * Given that the actual variable has just taken a value, restricts the    * domain of the remaining unassigned variables to discard invalid values.    * The function trimDomains is not exhaustive: it does not necessarily    * eliminate every invalid value from the domains.    */    protected abstract void trimDomains();        /**    * Reverse operation of trimDomains(). Given this function is called after    * trimDomains() and that "value" is the value that the actual variable had    * assigned when trimDomains() was called, the domains are restored to what    * they were before trimDomains().    * @param value the value that was assigned to the actual variable.    */    protected abstract void undoTrimDomains(Value value);        /**    * Indicates whether all variables have an assigned value or not.    * @return boolean indicating if all variables have been assigned.    */    protected abstract boolean allAssigned();        /**     * Indicates whether the actual variable has more domain values to be     * checked.      * @return boolean indicating if the actual variable has more values.     */    protected abstract boolean actualHasMoreValues();            /**     * Given that the actual variable has not been assigned yet and not all of     * its domain values have been checked, returns the next domain value to be     * checked.     * @return Value from the domain of the actual variable to be checked.     */    protected abstract Value getNextActualDomainValue();            /**    * Indicates whether assigning the value 'value' to the actual variable    * violates any restriction.    * @param value The Value being checked.    * @return boolean indicating if the assignment is valid.    */    protected abstract boolean canAssignToActual(Value value);        /**    * Given that the value "value" can be assigned to the actual variable, it    * effectuates the assignment.    * @param value The value to be assigned.    */    protected abstract void assignToActual(Value value);        /**    * Given that the actual variable has an assigned value, it is left    * unassigned.    * @param value The value to be assigned.    */    protected abstract void undoAssignToActual();        /**    * Eliminates values from the domains of the variables if they violate any    * restriction by themselves.    */    protected abstract void preliminarTrimDomains();        /**    * Tries to find a solution; that is, a value for each variable such that no    * restriction is violated.    * @throws NoSolutionException if there is no solution.    */    public void solve() throws NoSolutionException {        preliminarTrimDomains();        depth = 0;         backtracking();    }        /**     * Recursive method that applies forward checking to find a solution.     * @throws NoSolutionException      */    protected void backtracking() throws NoSolutionException {                setActualVariable();        while (!allAssigned() && actualHasMoreValues()) {            Value value = getNextActualDomainValue();            if (canAssignToActual(value)) {                assignToActual(value);                if (!allAssigned()) {                    trimDomains();                    ++depth;                    backtracking();                    --depth;                                        if (!allAssigned()) {                        undoAssignToActual();                        undoTrimDomains(value);                    }                }            }        }        if (!allAssigned() && depth == 0) noSolutionFound();       }        /**     * Throws a NoSolutionException() without any message.     * This method gets called when no solution has been found in backtracking().     * @throws NoSolutionException      */    protected void noSolutionFound() throws NoSolutionException {        throw new NoSolutionException();    }}